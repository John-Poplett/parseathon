\documentclass[presentation]{beamer}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{acronym}
\usepackage{minted}
\usepackage{tabularx}

% From http://www.mackichan.com/index.html?techtalk/564.htm~mainFrame
\setlength{\parindent}{0in} % remove indentation after first paragraph in a section
\setlength{\parskip}{10pt plus 1pt minus 1pt} % space between paragraphs

\begin{document}

% \title{Monadic Parser Combinators in Clojure with fnparse}
\title{Parseathon: The Joy of Parser Combinators}
\author{John Poplett\\
  \texttt{john.poplett@acm.org}}
\date{\today}

\begin{frame}[plain]
\titlepage
\end{frame}

\begin{frame}{Introduction}
fnparse, is a library for writing parsers in Clojure. The library
belongs to the class of parsing techniques known as parser combinators.

The goal of my talk today is to introduce you to fnparse (and
indirectly to parser combinators), show you how to use fnparse and
then spend some time working with it interactively.
\end{frame}

\begin{frame}{Agenda}

\begin{itemize}
\item Why parser combinators?
\item Parsing digits
\item Parsing telephone numbers
\item Introduction to fnparse
\item Look at some fnparse function parsers
\item REPL playtime: executing simple parsers
\item Recursive example with Protobuf
\item REPL playtime
\item Error handling with fnparse
\item Parser output
\item Example: htmltemplate
\item REPL playtime
\end{itemize}

\end{frame}

\begin{frame}{Parser Combinators}

  Parser combinators describe a class of parsers that are well-suited
  to functional languages. As the name implies, parser combinators are
  parsers made up of other parsers that also happen to be functions.

  Parser combinators result in recursive-descent parsers, top-down
  parsers of the class \href{http://en.wikipedia.org/wiki/LL_parser}{LL}(*).

  Parser combinator libaries generally include primitive parsers for
  literals, sequences and alternatives.

\end{frame}

\begin{frame}{The Joy of Parser Combinators}
\begin{quotation}
 A functional parser can be built using basic parsers for the terminal
 symbols, and non basic parser for the non-terminal symbols of a
 grammar. To create the latter, so-called parser combinators -
 implemented as higher-order functions - are used. It turns out that by
 using the functional parsing approach, large parts of the parser can
 in fact be generated automatically.
\end{quotation}
\end{frame}

\begin{frame}{The Joy of Parser Combinators}
\begin{quotation}
 The resulting functional parser has some very useful features which
 make it ideal for use in the software maintenance environment. The
 most important one is that the parser is incremental in its nature,
 which means that we automatically obtain a parser for every single
 production of the underlying grammar in EBNF. Moreover, due to this
 one-to-one correspondence between the parser and the EBNF productions,
 there is a very clean and consistent way to use the parser as a
 front-end for tools to be developed on top of it.\cite{Baumann}
\end{quotation}
\end{frame}

\begin{frame}{More Joy}

  Parser combinators are written using standard language functions. As
  noted in the article ``The Magic Behind Parser Combinators''\cite{Spiewak}

\begin{quotation}
  What's more, we can do this in a very declarative fashion.  Thanks
  to the magic of DSLs, our sources will actually look like a
  plain-Jane context-free grammar for our language.  This means that
  we get most of the benefits of a hand-written parser without losing
  the maintainability afforded by parser generators like bison.
\end{quotation}
\end{frame}

\begin{frame}{Introduction to fnparse}
  fnparse \cite{Choi} was written by Joshua Choi. A valuable text for
  understanding the library is written by Andrew Breihaut called
  \emph{Start Parsing in Clojure: fnparse} \cite{Breihaut}.  If this
  talk piques your interest in fnparse, read the article and also
  study, as he suggest's, the JSON parser example provided with
  fnparse.

  Joshua Choi the original author of fnparse no longer maintains it. I
  have created a fork of the original source on github and updated it
  for compatibility with Clojure 1.3 and 1.4.
\end{frame}

%
% fragile key word required to use minted in beamer frames
% See http://code.google.com/p/minted/issues/detail?id=40
%
\begin{frame}[fragile]{Phone Number in \ac{EBNF}}
\begin{minted}{sh}
digit = ``0'', ``1'', ``2'', ``3'', ``4'', ``5'',
            ``6'', ``7'', ``8'', ``9'' ;
areacode = ``('' 3*digit ``)'' ;
exchange = 3*digit;
suffix = 4*digit;
telno = areacode space exchange ``-'' suffix;
\end{minted}
\end{frame}

\begin{frame}[fragile]{Digit Parser}
\begin{minted}{clojure}
(def
  #^{:doc "Defines a parser that succeeds when
     the input matches a single digit."}
  digit (lit-alt-seq "0123456789"))

(defmacro ndigits
  "Creates a parser for the specified number of digits. The
  parser returns a string of the matching digits on success."
  [n] `(semantics (rep= ~n digit) #(apply str %)))
\end{minted}
\end{frame}

\begin{frame}[fragile]{Phone Number Parser}
\begin{minted}{clojure}
(defstruct telno-s :areacode :exchange :suffix)

(def areacode (complex [_ (lit \()
                                      result (ndigits 3)
                                      _ (lit \))]
                                    result))

(def exchange (ndigits 3))
(def suffix (ndigits 4))
(def space (lit \space))
(def hyphen (lit \-))

\end{minted}
\end{frame}

\begin{frame}[fragile]{Phone Number Parser (cont)}
\begin{minted}{clojure}

(def #^{:doc "A complete parser for a telephone-number."}
  telno
  (complex [areacode areacode
            _ space
            exchange exchange
            _ hyphen
            suffix suffix]
           (struct telno-s areacode exchange suffix)))

\end{minted}
\end{frame}

\begin{frame}[fragile]{What about Regular Expressions?}

\begin{minted}{clojure}
(def telno-pattern "\\((\\d{3})\\) (\\d{3})-(\\d{4})")

 (defn telno-regex [input]
  (let [result (re-find (re-pattern telno-pattern) input)]
    (if result
      (let [areacode (nth result 1)
            exchange (nth result 2)
            suffix (nth result 3)]
        (struct telno-s areacode exchange suffix))
      nil)))
\end{minted}
\end{frame}

\begin{frame}{fnparse primitives}

\begin{table}
\begin{tabularx}{\linewidth}{|l|l|X|X|}
\hline
  \emph{Name} & \emph{EBNF}  & \emph{Description} & \emph{Example} \\ \hline
  alt & \textbar & Creates a rule that is true if any of the alternates
  are true. & (def alpha (alt lower upper)) \\ \hline
  opt & [...] &  A rule that is satisfied if it is present or
  absent. & (def trailing-whitespace (opt whitespace)) \\ \hline
  rep* and rep+ & {...} &  A rule for subrules that repeat. &
  \texttt{(def statements (conc statement (rep* (conc ws statement))))} \\ \hline
\end{tabularx}
\end{table}

\end{frame}
\begin{frame}{fnparse primitives (cont)}

\begin{table}
\begin{tabularx}{\linewidth}{|l|l|X|X|}
\hline
  \emph{Name} & \emph{EBNF}  & \emph{Description} & \emph{Example} \\
  \hline
  lit & ``x'' & Define a rule for a literal, character value. &
  \texttt{(def blank (alt (lit \textbackslash space) (lit
    \textbackslash tab)))} \\ \hline
  conc & , & Creates a rule by concatenating rules. &
 \texttt{(def camelback (conc upper (rep* alpha)))} \\ \hline
  lit-alt-seq & ``x'', ``x'' & Creates a parser for alternatives
  derived from a specified sequence. &
  \texttt{(def digits (lit-alt-seq ``0123456789''))} \\
  \hline
\end{tabularx}
\end{table}

\end{frame}

\begin{frame}{Constructing Non-terminals}
\begin{itemize}
\item white space
\item identifiers
\item keywords
\item numeric representations (e.g. hex values)
\item Posix character classes (digit, alpha, word, upper, .etc)
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Posix Character Classes}

 Posix defines character classes for blank, lower, upper,
 xdigit, alpha, alnum, etc.

 Earlier we defined ``digit''  with \texttt{lit-alt-seq}.

\begin{minted}{clojure}
def digit (lit-alt-seq "0123456789"))
\end{minted}

We can use a utility macro, ``test-set'' to make this more
succinct:

\begin{minted}{clojure}
(def digit (term #(contains? (test-set [\0 \9]) %)))
\end{minted}

Now we need definitions for more like xdigit, lower, upper, alpha and
word!
\end{frame}

\begin{frame}[fragile]{Posix Character Classes}

% Here is an example set of complete definitions:

\begin{minted}{clojure}
(def
  #^{:doc "Defines a parser that succeeds when
     the input matches a single digit."}
  digit (term #(contains? (test-set [\0 \9]) %)))

(def blank (alt (lit \space) (lit \tab)))
(def lower (term #(contains? (test-set [\a \z]) %)))
(def upper (term #(contains? (test-set [\A \Z]) %)))
(def xdigit (term #(contains? (test-set [\a \f] [\A \F] [\0 \9]) %)))
(def alpha (alt lower upper))
(def alnum (alt alpha digit))
(def word (alt alnum (lit \_)))
\end{minted}

\end{frame}

\begin{frame}[fragile]{Protobuf fragment}

  Protobuf is an IDL and compiler for machine-to-machine data
  interchange.

\begin{minted}{protobuf}
 message SearchResponse {
  message Result {
    required string url = 1;
    optional string title = 2;
    repeated string snippets = 3;
  }
  repeated Result result = 1;
}
\end{minted}
\end{frame}

\begin{frame}[fragile]{Protobuf identifer}

\begin{minted}{sh}
 identifier = alpha | ``_'', { word }
\end{minted}

\begin{minted}{sh}
 (def protobuf-identifier (semantics (conc alpha (rep* alpha-plus))
                                (fn [result] (apply str (flatten result)))))
\end{minted}

\end{frame}

\begin{frame}[fragile]{HTML-TEMPLATE: a Case Study}
HTML-TEMPLATE is template language. Like many template engines, it
generates HTML or XML dynamically from a template.

\begin{minted}{html}
<table border=1>
  <!-- TMPL_LOOP rows -->
  <tr>
     <!-- TMPL_LOOP cols -->
     <!-- TMPL_IF colorful-style -->
     <td align="right" bgcolor="pink"><!-- TMPL_VAR content --></td>
     <!-- TMPL_ELSE -->
     <td align="right" ><!-- TMPL_VAR content --></td>
     <!-- /TMPL_IF -->
     <!-- /TMPL_LOOP -->
 </tr>
 <!-- /TMPL_LOOP -->
</table>
\end{minted}

\end{frame}

\begin{frame}{References}

\begin{thebibliography}{9}

\bibitem{Baumann} Peter Baumann et al,
\emph{Using Functional Parsing to Achieve Quality in Software
  Maintenance},
Institute fur Informatik der Universitat Zurich.

\bibitem{Spiewak} Daniel Spiewak,
\href{http://www.codecommit.com/blog/scala/the-magic-behind-parser-combinators}{\emph{The
Magic Behind Parser Combinators}}, www.codecommit.com (2009).

\bibitem{Choi} Joshua Choi,
  \href{https://github.com/joshua-choi/fnparse/wiki/Reference-of-FnParse-2}{\emph{fnparse Reference}}.

\bibitem{Breihaut} Andrew Breihaut,
\href{http://brehaut.net/blog/2011/fnparse_introduction}{\emph{Start
    Parsing in Clojure: fnparse}}. February 2011.

\bibitem{Duey} Jim Duey,
\href{http://www.intensivesystems.net/tutorials/monads_101.html}{\emph{Monads in Clojure}},
www.intensivesystems.com (2009).

\bibitem{Meijer} Graham Hutton \& Erik Meijer, \emph{Monadic Parser Combinators}, University
of Nottingham (1996).

\bibitem{lpn} Shaopeng Jia,
\href{https://docs.google.com/present/view?id=0Ae6JSEqM3Qz6ZDk0bmd3d18yODRmejZ2N21kdw}{\emph{libphonenumber:
    A Deeper Look}}, Google (2010).

\end{thebibliography}

\end{frame}

\begin{frame}{Acronyms}
  \begin{acronym}[EBNF]
  \acro{AST}{Abstract syntax tree}
  \acro{EBNF}{Extended Backus-Naur Form}
  \acro{DSL}{Domain specific language}
  \end{acronym}
\end{frame}

\end{document}
